#+title: Farlado's Illiterate GNU Emacs üê≤
#+subtitle: A slightly-less-insane GNU Emacs configuration
#+author: Farlado
#+language: en
#+startup: hideblocks
#+options: num:nil toc:2
#+property: header-args :results none
#+html: <p align="center"><img src="logo.png" /></p>

#+begin_quote
Personally, I feel inspired whenever I open Emacs.  Like a craftsman entering
his workshop, I feel a realm of possibility open before me.  I feel the comfort
of an environment that has evolved over time to fit me perfectly -- an
assortment of packages and keybindings which help me bring ideas to life day
after day.
-- [[https://www.braveclojure.com/basic-emacs/][Daniel Higginbotham]]
#+end_quote

* Table of Contents :toc:quote:
#+BEGIN_QUOTE
- [[#about-this-configuration][About this configuration]]
  - [[#installation][Installation]]
  - [[#dependencies][Dependencies]]
  - [[#license][License]]
- [[#file-headers][File headers]]
- [[#startup][Startup]]
  - [[#getting-ready-to-get-ready][Getting ready to get ready]]
  - [[#early-package-management][Early package management]]
  - [[#later-package-management][Later package management]]
- [[#looks][Looks]]
  - [[#font][Font]]
  - [[#theme][Theme]]
  - [[#mode-line][Mode line]]
  - [[#start-screen][Start screen]]
  - [[#other-elements][Other elements]]
#+END_QUOTE

* About this configuration

  This file is a second attempt at a literate GNU Emacs (henceforth "Emacs")
  configuration for use as a desktop environment.

  Literate programming is a method in which documentation and code are authored
  in tandem with each other, allowing for easy modification and explanation of
  how a program or configuration was written, and how to properly use it.  The
  end result is a file that can be /tangled/ into source code and /weaved/ into
  documentation.  The benefits of this practice are easier maintenance of a
  rapidly growing project, and far greater control over when and where code is
  introduced in documentation compared to its necessary position in source
  code.  This allows for readable code documentation introduced in the
  conceptual order, while ensuring code is arranged correctly when tangled and
  compiled.

  This configuration is /wildly/ opinionated, and you'll probably *hate* it if you
  aren't tweaking it like crazy.  I recommend only editing this file, because
  the =.el= files are built from here.  It's a real jungle out there.

** Installation

   1) Clone this repository into the place you store your Emacs configuration.
   2) Open and reopen Emacs a few times just to be safe.  See below.

** Dependencies

   #+begin_center
   *THIS CONFIGURATION IS MEANT FOR EMACS 27 AND LATER.  IT WILL VERY LIKELY /NOT/
   LOAD PROPERLY ON EMACS 26 OR EARLIER. THE BRANCH FOR EMACS 26 OR EARLIER IS [[https://github.com/farlado/dotemacs/tree/emacs26-end][HERE]].*
   #+end_center

   Historically, this configuration relied upon the user installing the majority
   of the dependencies. Thanks to ~system-package-ensure~, most dependencies will
   now install automatically. If you are building an X window environment from
   scratch, you will need to acquire a bare minimum of your distribution's X
   server.

** License

   Farlado's Illiterate GNU Emacs is licensed under version 3 of the GNU General
   Public License.  This is just a general practice for anything related to
   Emacs, so I see no reason not to break from this practice.

   #+name: license
   #+begin_src emacs-lisp
     ;; This program is free software; you can redistribute it and/or modify
     ;; it under the terms of the GNU General Public License as published by
     ;; the Free Software Foundation, either version 3 of the License, or
     ;; (at your option) any later version.

     ;; This program is distributed in the hope that it will be useful,
     ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ;; GNU General Public License for more details.

     ;; You should have received a copy of the GNU General Public License
     ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.
   #+end_src

* File headers

  In order to make the files look at least somewhat decent for documentation
  linters, and to warn those who are unfortunate enough to think they'll just
  mosey on into one of them if they want to understand the config, we create
  headers that tell people the reality of the files.

*** =early-init.el=

    #+begin_src emacs-lisp :noweb yes :tangle "early-init.el"
      ;;; early-init.el --- Early startup for Farlado's Illiterate GNU Emacs

      ;; This file is not part of GNU Emacs.

      <<license>>

      

      ;;; Commentary:

      ;; This file has been automatically tangled from `literate-emacs.org'.
      ;; If you don't have a copy of that file, it is best not to use this file!
      ;; All relevant commentary is in `literate-emacs.org', not here.
      ;; There may not be any comments past this point.
      ;; Abandon all hope, ye who enter here.

      

      ;;; Code:
    #+end_src

*** =init.el=

    #+begin_src emacs-lisp :noweb yes :tangle "init.el"
      ;;; init.el --- Initializing Farlado's Illiterate GNU Emacs

      ;; This file is not part of GNU Emacs.

      <<license>>

      

      ;;; Commentary:

      ;; This file has been automatically tangled from `literate-emacs.org'.
      ;; If you don't have a copy of that file, it is best not to use this file!
      ;; All relevant commentary is in `literate-emacs.org', not here.
      ;; There may not be any comments past this point.
      ;; Abandon all hope, ye who enter here.

      

      ;;; Code:
    #+end_src

* Startup

  There is no better place to start than the beginning, no?

** Getting ready to get ready
   :properties:
   :header-args: :tangle "early-init.el"
   :end:

   Emacs 27 introduced the file =early-init.el= to allow for earlier loading of
   some items before any frame has visually opened.  These are things which are
   configured as soon as it is possible.

*** Prepare GUI (Part 1)

    These are visual elements which are enabled by default but are
    counterintuitive in Emacs.  They take up precious screen real estate and
    does anyone /actually/ use them?

    #+begin_src emacs-lisp
      (menu-bar-mode -1)
      (tool-bar-mode -1)
      (scroll-bar-mode -1)

      (when (getenv "_RUN_EXWM")
        (set-face-background 'default "#282a36"))
    #+end_src

*** Byte-compile if not already done

    Something that can really speed up start time is byte-compiling the
    configuration files.  It's done after loading, to prevent wonky behaviors
    from occurring.

    #+begin_src emacs-lisp
      (defun farl-init/compile-user-emacs-directory ()
        "Recompile all files in `user-emacs-directory'."
        (byte-recompile-directory user-emacs-directory 0))

      (unless (file-exists-p (locate-user-emacs-file "init.elc"))
        (add-hook 'after-init-hook #'farl-init/compile-user-emacs-directory))
    #+end_src

*** Prefer the newest file when loading

    If there's both a byte-compiled configuration and a new one which hasn't
    been compiled, prefer the newer one.  This ensures that changed pulled from
    GitHub are actually applied the next time Emacs loads.

    #+begin_src emacs-lisp
      (setq load-prefer-newer t)
    #+end_src

*** More complete apropos

    Even if marginally slower, this makes ~apropos~ look through /everything/ when
    run.  This is helpful for ensuring that when looking for something, every
    potential option is shown.

    #+begin_src emacs-lisp
      (setq-default apropos-do-all t)
    #+end_src

*** File name handling setup

    For some reason or another, this makes loading faster.  I don't know how it
    does that exactly, but it does.

    #+begin_src emacs-lisp
      (defvar startup/file-name-handler-alist file-name-handler-alist
        "Temporary storage for `file-name-handler-alist' during startup.")

      (defun startup/revert-file-name-handler-alist ()
        "Revert `file-name-handler-alist' to its default value after startup."
        (setq file-name-handler-alist startup/file-name-handler-alist))

      (setq file-name-handler-alist nil)
      (add-hook 'emacs-startup-hook #'startup/revert-file-name-handler-alist)
    #+end_src

*** Defer garbage collection

    Garbage collection is a task which can take up considerable time during
    Emacs startup.  This should preferably be deferred, and more preferable
    settings are put in place after Emacs is finished starting up.

    #+begin_src emacs-lisp
      (defun farl-init/garbage-collect-defer ()
        (setq gc-cons-threshold most-positive-fixnum
              gc-cons-percentage 0.6))

      (defun farl-init/garbage-collect-restore ()
        "Return garbage collection to sane parameters."
        (setq gc-cons-threshold 16777216
              gc-cons-percentage 0.1))

      (farl-init/garbage-collect-defer)
      (add-hook 'emacs-startup-hook #'farl-init/garbage-collect-restore)
    #+end_src

** Early package management
   :properties:
   :header-args: :tangle "early-init.el"
   :end:

   I write this configuration to be as portable as possible.  Some people prefer
   their Emacs packages to be installed through their distribution's package
   manager, but I want this configuration to be usable no matter what machine
   it's being loaded on.  For that reason, I use the built-in Emacs package
   manager.  As much of package management as can be done prior to calling
   ~package-initialize~ is included here.

*** Disable customize but keep ~package-autoremove~ working

    I /hate/ ~customize~.  I hate it with a burning passion.  It messes with every
    single intuition I have about configuring Emacs, and tries to modify =init.el=
    every time it seeks to change a variable.  However, I really like using the
    function ~package-autoremove~ so I'm stuck listing all my used packages here.
    I tried my best to list packages in the order they appear in this file.

    #+begin_src emacs-lisp
      (setq custom-file "/tmp/custom.el"
            package-selected-packages '(;; First loaded packages
                                        async
                                        use-package
                                        system-packages
                                        auto-package-update
                                        try

                                        ;; Looks
                                        dracula-theme
                                        mood-line
                                        dashboard
                                        page-break-lines
                                        rainbow-mode
                                        rainbow-delimiters

                                        ;; Functionality
                                        which-key
                                        counsel
                                        company
                                        company-emoji
                                        buffer-move

                                        ;; Text editing
                                        sudo-edit
                                        swiper
                                        popup-kill-ring
                                        hungry-delete
                                        avy

                                        ;; Programming
                                        magit
                                        flycheck
                                        flycheck-package
                                        flycheck-posframe
                                        avy-flycheck

                                        ;; `org-mode'
                                        toc-org
                                        org-bullets
                                        epresent

                                        ;; Extensions
                                        nov
                                        wttrin

                                        ;; Games
                                        yahtzee
                                        sudoku
                                        chess
                                        2048-game

                                        ;; Media
                                        emms

                                        ;; Desktop Environment
                                        exwm
                                        minibuffer-line
                                        system-packages
                                        desktop-environment
                                        wallpaper))
    #+end_src

*** Disable an annoying ~customize~ function

    Since I don't use ~customize~, we don't need to mess with it every time a
    package is installed or uninstalled.  This also ensures that nothing changes
    =package-saved-packages=.  This also loads package management itself.

    #+begin_src emacs-lisp
      (require 'package)
      (defun package--save-selected-packages (&rest opt)
        "Return nil, ignoring OPT.

      This function was altered to inhibit a specific undesired behavior."
        nil)
    #+end_src

*** Configure package repositories

    Next, we have to add package repositories to the list.  The GNU and MELPA
    repositories are enough to last me my life and then some.

    #+begin_src emacs-lisp
      (setq package-archives '(("gnu"   . "https://elpa.gnu.org/packages/")
                               ("melpa" . "https://melpa.org/packages/")))
    #+end_src

** Later package management
   :properties:
   :header-args: :tangle "init.el"
   :end:

   Between =early-init.el= and =init.el=, ~package-initialize~ is called.  This is the
   point at which we now move into configuring the most basic packages needed to
   manage all other packages.

*** Easy configuration

    This is the most elegant way to configure packages in Emacs.  Recently I
    discovered a few tricks which make it far more compact and readable.

    #+begin_src emacs-lisp
      (unless (package-installed-p 'use-package)
        (package-refresh-contents)
        (package-install 'use-package))

      (require 'use-package)
      (setq use-package-compute-statistics t
            use-package-always-ensure t
            use-package-always-defer t)
    #+end_src

*** Asynchronous code execution

    Emacs is a single-threaded program still.  This is okay for the most part,
    since it seems like most of the kinks that make everything lock up are
    becoming less and less present.

    #+begin_src emacs-lisp
      (use-package async
        :custom ((direct-async-mode t)
                 (async-bytecomp-package-mode t)
                 (async-bytecomp-allowed-packages '(all))))
    #+end_src

*** Installing dependencies easier

    This is a pleasant surprise to have.  Letting Emacs handle system packages
    as well as its own makes this configuration a bajillion times easier to
    manage.  Since I use ~yay~ on Arch, I configure and entry for it and use it if
    it's installed.  It can also manage packages manually.

    #+begin_src emacs-lisp
      (use-package system-packages
        :init
        (use-package use-package-ensure-system-package)
        (when (executable-find "yay")
          (require 'system-packages)
          (add-to-list 'system-packages-supported-package-managers
                       '(yay .
                             ((default-sudo . nil)
                              (install . "yay -S")
                              (search . "yay -Ss")
                              (uninstall . "yay -Rs")
                              (update . "yay -Syu")
                              (clean-cache . "yay -Sc")
                              (log . "car /var/log/pacman.log")
                              (get-info . "yay -Qi")
                              (get-info-remote . "yay -Si")
                              (list-files-provided-by . "yay -Ql")
                              (verify-all-packages . "yay -Qkk")
                              (verify-all-dependencies . "yay -Dk")
                              (remove-orphaned . "yay -Rns $(yay -Qtdq)")
                              (list-installed-packages . "yay -Qe")
                              (list-installed-packkages-all . "yay -Q")
                              (list-dependencies-of . "yay -Qi")
                              (noconfirm . "--noconfirm"))))
          (setq system-packages-use-sudo nil
                system-packages-package-manager 'yay))
        :custom (system-packages-noconfirm t)
        :bind (("C-c p i" . system-packages-install)
               ("C-c p e" . system-packages-ensure)
               ("C-c p u" . system-packages-update)
               ("C-c p r" . system-packages-uninstall)
               ("C-c p o" . system-packages-remove-orphaned)
               ("C-c p c" . system-packages-clean-cache)
               ("C-c p l" . system-packages-log)
               ("C-c p s" . system-packages-search)
               ("C-c p g" . system-packages-get-info)
               ("C-c p d" . system-packages-list-dependencies-of)
               ("C-c p f" . system-packages-list-files-provided-by)
               ("C-c p p" . system-packages-list-installed-packages)
               ("C-c p f" . system-packages-verify-all-dependencies)
               ("C-c p v" . system-packages-verify-all-packages)))
    #+end_src

*** Automatic package updates

    I don't like having to manually update stuff. This solution is literally one
    which I added when I first started using Emacs, and I haven't had to change
    anything significant about it since.

    #+begin_src emacs-lisp
      (use-package auto-package-update
        :custom ((auto-package-update-interval 2)
                 (auto-package-update-hide-results t)
                 (auto-package-update-delete-old-versions t))
        :hook (after-init . auto-package-update-maybe))
    #+end_src

*** Trying packages on the fly

    This allows me to try out a package from the repository without actually
    installing it.  When Emacs closes, the package is removed.

    #+begin_src emacs-lisp
      (use-package try)
    #+end_src

* Looks

  Stock Emacs is /ugly/.  I don't know who in their right mind would /want/ to use
  it.  Suffice to say it leaves much to be desired.  This ranges from trivial
  things to things which make my eyes burn.  This section fixes all of that so
  Emacs isn't an eyesore.

** Font
   :properties:
   :header-args: :noweb-ref theme-init
   :end:

   A text editor that can't display text well isn't a text editor at all. Also,
   packages which are built into Emacs need not be ensured, since they will not
   show up in ELPA or MELPA.

*** Use UTF-8

    Why on God's good green hollow flat earth isn't this the default?!  Also,
    Built-in packages such as ~mule~ need not be ensured, since we know they are
    built into Emacs as it is.

    #+begin_src emacs-lisp
      (prefer-coding-system 'utf-8)
      (setq locale-coding-system 'utf-8)
      (set-language-environment "UTF-8")
      (set-default-coding-systems 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (set-selection-coding-system 'utf-8)
    #+end_src

*** Set font style

    Originally this was done using ~custom-set-faces~, but that is less easily
    configured than the way I do it now.

    #+begin_src emacs-lisp
      (unless (member "Iosevka" (font-family-list))
        (system-packages-install "ttf-iosevka"))
      (when (member "Iosevka" (font-family-list))
        (set-face-attribute 'default nil
                            :font "Iosevka"
                            :height 100))
    #+end_src

*** Making emoji work

    Does exactly what it says on the tin.

    #+begin_src emacs-lisp
      (unless (member "Noto Color Emoji" (font-family-list))
        (system-packages-install "noto-fonts-emoji"))
      (when (member "Noto Color Emoji" (font-family-list))
        (set-fontset-font t 'symbol
                          (font-spec :family "Noto Color Emoji")
                          nil 'prepend))
    #+end_src

*** Don't unload fonts

    This solves a number of hanging issues when using special symbols.  Emacs
    otherwise gets annoyingly slow.

    #+begin_src emacs-lisp
      (setq inhibit-compacting-font-caches t)
    #+end_src

** Theme
   :properties:
   :header-args: :noweb-ref theme-init
   :end:

   I've gone through many themes over the years, but Dracula has served me the
   best of all of them.  It's a theme which spans many programs, enabling me to
   have greater uniformity in the look of my system.  Other small details which
   couldn't be handled in =early-init.el= are handled here.

   #+begin_src emacs-lisp :noweb yes :tangle "init.el" :noweb-ref nil
     (use-package dracula-theme
       :if window-system
       :init
       (load-theme 'dracula t)
       (tooltip-mode -1)
       (setq use-dialog-box nil
	     use-file-dialog nil)
       <<theme-init>>)
   #+end_src

*** Fringes

    Having a margin for special symbols to be shown is really nice, and makes it
    possible to show more information more easily.  Some themes don't have a
    sane fringe background color, so this ensures whatever theme I use has a
    proper background color: the same one as the rest of the background.

    #+begin_src emacs-lisp
      (set-face-background 'fringe (face-background 'default))
    #+end_src

*** Line numbers

    Some themes give line numbers a different background color from the rest of
    the window.  That looks tacky and easily distracts me.

    #+begin_src emacs-lisp
      (set-face-background 'line-number (face-background 'default))
    #+end_src

*** Window dividers

    Window dividers make Emacs look far less sloppy, and provide divisions
    between windows that are significantly more visible.  The color is from the
    mode line, for consistency.  Three pixels seems the most sane size for the
    monitors I use.

    #+begin_src emacs-lisp
      (setq window-divider-default-right-width 3)
      (let ((color (face-background 'mode-line)))
        (dolist (face '(window-divider-first-pixel
                        window-divider-last-pixel
                        window-divider))
          (set-face-foreground face color)))
      (window-divider-mode 1)
    #+end_src

*** Transparent frames

    If there's any other gimmick I've fallen in love with, it comes nowhere
    close to the love I have for transparent frames.  At first, I thought it
    would make things harder to read since background and foreground elements
    aren't distinguished when a frame is transparent, but that has never been
    the case for me.

    #+begin_src emacs-lisp
      (dolist (frame (frame-list))
        (set-frame-parameter frame 'alpha 90))
      (add-to-list 'default-frame-alist '(alpha . 90))
    #+end_src

** Mode line
   :properties:
   :header-args: :noweb-ref mode-line-init
   :end:

   The default mode line is a total mess and an absolute disaster.  This mode
   line is sleek and simply, with a compact look and saved frustration.  I've
   explored many mode lines, but this is the fastest and most convenient I've
   used.  It combines the compactness of ~spaceline~ with the minimalism of
   ~doom-modeline~.

   #+begin_src emacs-lisp :noweb yes :tangle "init.el" :noweb-ref nil
     (use-package mood-line
       :init
       (mood-line-mode 1)
       <<mode-line-init>>)
   #+end_src

*** Show line/column numbers

    Why isn't this enabled by default on a /text editor/?  What line and column
    the point is on should always be visible on the mode line.  I don't know if
    I need to enable these for ~mood-line~, but here we are.

    #+begin_src emacs-lisp
      (line-number-mode 1)
      (column-number-mode 1)
    #+end_src

*** Show clock

    This is just something I do out of convenience, so that I have the time and
    date right in front of my face no matter what I'm doing.

    #+begin_src emacs-lisp
      (display-time-mode 1)
      :custom ((display-time-format "%a %m/%d %H:%M")
               (display-time-day-and-date t)
               (display-time-24hr-format t))
    #+end_src

** Start screen

   The default screen is nice when you are first using Emacs, and it contains
   useful links for the beginner, but I want something with more customization,
   in case I actually need to be productive and put things on my start screen.
   For now, all I really have is a custom banner.

   The default screen is nice when you are first using Emacs, and it contains
   many useful links , but personally I want something with more options to
   customize.  This package provides that, and works incredibly well.  A custom
   banner is displayed and recent files are shown.

   #+begin_src emacs-lisp :noweb yes :tangle "init.el"
     (use-package dashboard
       :init
       <<dashboard-init>>
       (dashboard-setup-startup-hook)
       :custom ((inhibit-start-screen t)
                (dashboard-set-footer nil)
                (dashboard-startup-banner (locate-user-emacs-file "logo.png"))
                (dashboard-items '((recents . 10)))
                (initial-buffer-choice #'dashboard-or-scratch)
                (dashboard-banner-logo-title
                 "Welcome to Farlado's Illiterate GNU Emacs!"))
       :hook (dashboard-mode . dashboard-immortal))
   #+end_src

*** Show dashboard or scratch initially

   When Emacs or ~emacsclient~ starts, the first buffer shown should be either
   dashboard or a scratch buffer.  To prevent use of a lambda (something I
   have come to try to avoid where I can for a number of good reasons).

   #+begin_src emacs-lisp :noweb-ref dashboard-init
     (defun dashboard-or-scratch ()
       "Open either dashboard or the scratch buffer."
       (or (get-buffer "*dashboard*")
           (get-buffer "*scratch*")))
   #+end_src

*** Make the dashboard buffer immortal

   The dashboard buffer itself should be immortal.  I used to close it all the
   time, and this is meant to prevent that by hooking ~emacs-lock-mode~ into
   =dashboard-mode-hook= to lock the buffer from being killed.

   #+begin_src emacs-lisp :noweb-ref dashboard-init
     (defun dashboard-immortal ()
       "Make the dashboard buffer immortal."
       (emacs-lock-mode 'kill))
   #+end_src

** Other elements
   :properties:
   :header-args: :tangle "init.el"
   :end:

   These are things for which I've yet to find an appropriate place.  Think of
   it like the dish washer when you finish washing the dishes but don't feel
   like putting them away.

*** Word wrapping

    This ensures that lines longer than the buffer width wrap around for
    readability.

    #+begin_src emacs-lisp
      (global-visual-line-mode 1)
    #+end_src

* Comfort
  :properties:
  :header-args: :tangle "init.el"
  :end:

  Anyone who has used Emacs for any amount of time knows that it can take a lot
  to make Emacs comfortable for one's personal use.  That is not to say that
  Emacs is /bad/, but it definitely isn't the most usable software immediately
  out of the box.  These settings are made for my own personal comfort.

** General

   These are general-purpose improvements meant to make integration with other
   software easier.  This includes things from stopping undesired behaviors to
   making Emacs run generally smoother.

*** Emacs server

    Having the Emacs server running allows for a lot of neat integration with
    other parts of my desktop environment.  I don't want to try to start a
    server if one is already running, though.

    #+begin_src emacs-lisp
      (require 'server)
      (unless (server-running-p)
	(server-start))
    #+end_src

*** Remove training wheels

    I'm a big boy now, no need for anyone to hold my hand.  Since I do not use
    ~customize~, this has to be set every time Emacs starts.

    #+begin_src emacs-lisp
      (setq disabled-command-function nil)
    #+end_src

*** Don't hang the minibuffer

    Garbage collection hits *really* hard when the minibuffer is in use.  I'm not
    entirely certain if it's actually causing major changes under the hood, but
    it /feels/ a little more responsive.

    #+begin_src emacs-lisp
      (add-hook 'minibuffer-setup-hook #'farl-init/garbage-collect-defer)
      (add-hook 'minibuffer-exit-hook #'farl-init/garbage-collect-restore)
    #+end_src

*** Confirm exiting Emacs

    This prevents me from accidentally closing Emacs and losing my arrangement
    of buffers, windows, and frames +as easily+.  Having to always confirm when I
    quit Emacs is way better than accidentally closing it when I don't want to.

    #+begin_src emacs-lisp
      (setq confirm-kill-emacs #'yes-or-no-p)
    #+end_src

*** Saner scrolling

    Why scrolling is how it is, that's anyone's guess.  I don't worry anymore.
    The goal is to make scrolling more friendly, e.g. it always scrolls one line
    at a time and the cursor stays where it is on the display.

    #+begin_src emacs-lisp
      (setq scroll-margin 0
	    auto-window-vscroll nil
	    scroll-preserve-screen-position 1
	    scroll-conservatively most-positive-fixnum
	    mouse-wheel-scroll-amount '(1 ((shift) . 1))
	    mouse-wheel-progressive-speed nil
	    mouse-wheel-follow-mouse t)
    #+end_src

*** Don't make noise

    Sound is obnoxious and it should be visibly obvious without flashing the
    frame or mode line that something has gone wrong.

    #+begin_src emacs-lisp
      (setq ring-bell-function 'ignore)
    #+end_src

*** Use "y or n" prompts

    Beauty in brevity.

    #+begin_src emacs-lisp
      (defalias 'yes-or-no-p #'y-or-n-p
        "Use `y-or-n-p' instead of `yes-or-no-p')
    #+end_src

** Completion helpers

   These help complete anything for which I need a reminder.

*** ~which-key~ (is it anyway?)

    Even when you already know the Emacs keys, having a little popup for those
    more obscure binds really helps.  Also configured here is near-instant
    display of what commands have been entered.

    #+begin_src emacs-lisp
      (use-package which-key
        :custom (echo-keystrokes 0.00000001)
        :hook (after-init . which-key-mode))
    #+end_src

*** Auto-complete for documents

    This is the base for a number of autocomplete engines.  I changed some of
    the keybinds to make it more pleasant to use.  It's got way more uses than
    just for programming: this is a surprise tool we will use later!

    #+begin_src emacs-lisp
      (use-package company
        :custom ((company-idle-delay 0.75)
                 (company-minimum-prefix-length 3))
        :hook (after-init . global-company-mode)
        :bind (:map company-active-map
               ("M-n" . nil)
               ("M-p" . nil)
               ("C-n" . company-select-next)
               ("C-p" . company-select-previous)
               ("SPC" . company-abort)))
    #+end_src
